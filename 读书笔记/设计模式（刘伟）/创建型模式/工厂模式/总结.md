[TOC]

# 问题描述

对象的责任常常有三类：
- 对象本身所具有的职责：对象自身所具有的一些数据和行为
- 创建对象的职责
    - 使用new关键字直接创建对象
    - 通过反射机制创建对象
    - 通过clone()方法创建对象
    - 通过反序列化创建对象
- 使用对象的职责：调用对象的各种方法

为了遵循OOP的开闭原则，实现系统的低耦合，需要将创建对象和使用对象这两种职责分开，并且还能封装复杂对象的初始化过程。  

# 解法

[简单工厂模式](./简单工厂模式.md)  

[工厂方法模式](./工厂方法模式.md)  

[抽象工厂模式](./抽象工厂模式.md)

# 适用场景

## 简单工厂模式

- 工厂负责创建的对象较少
- 客户端只知道传入工厂的参数，不关心如何创建

## 工厂方法模式

- 客户端不知道它所需要的对象的类。在工厂方法模式中,客户端不需要知道具体产品类的类名,只需要知道所对应的工厂即可,具体的产品对象由具体工厂类创建,可将具体工厂类的类名存储在配置文件或数据库中

## 抽象工厂模式

- 产品数量很多，并且产品能形成一个族

# 效果

## 简单工厂模式

### 优点

- 实现了对象创建和对象使用的分离
- 客户端无需知道具体产品的类型，只需要知道产品对应的参数即可获得对象
- 通过引入配置文件，可在不修改客户端代码的情况下更换和添加新的产品类

### 缺点

- 工厂类集中了所有的创建逻辑，职责过重，一旦不能工作将影响整个系统
- 增加了系统中类的个数，增加了系统的复杂性
- 新增产品的时候需要修改工厂源码，违反开闭原则
- 工厂使用了静态方法，因此工厂无法形成基于继承的等级结构

## 工厂方法模式

### 优点

- 实现了对象创建和对象使用的分离
- 通过将工厂抽象，减轻了工厂类的职责
- 客户端无需知道具体产品的类型，只需要知道产品对应的工厂即可获得对象
- 新增产品类时，不需要修改工厂源码，仅仅创建新的产品，和产品的工厂即可，不需要修改已有的源码，符合开闭原则

### 缺点

- 增加了系统中类的个数，增加了系统的复杂性
- 客户端中均使用抽象层定义，在实现时可能会用到DOM、反射等技术，增加了实现难度

## 抽象工厂模式

### 优点

- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
- 新增新的产品族很方便，符合开闭原则

### 缺点

- 增加新的产品等级结构很麻烦，需要对原有设计做大修改，不符合开闭原则，因此再设计时需要多多考虑与思考

